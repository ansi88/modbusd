<?xml version='1.0' encoding='utf-8'?>
<struct id="UT_hash_table" name="UT_hash_table" typedef="yes" xmlns="http://jessevdk.github.com/cldoc/1.0">
  <field id="UT_hash_table::buckets" name="buckets">
    <type name="UT_hash_bucket" qualifier="*" ref="UT_hash_bucket#UT_hash_bucket" />
  </field>
  <field id="UT_hash_table::num_buckets" name="num_buckets">
    <type builtin="yes" name="unsigned int" />
  </field>
  <field id="UT_hash_table::log2_num_buckets" name="log2_num_buckets">
    <type builtin="yes" name="unsigned int" />
  </field>
  <field id="UT_hash_table::num_items" name="num_items">
    <type builtin="yes" name="unsigned int" />
  </field>
  <field id="UT_hash_table::tail" name="tail">
    <type name="UT_hash_handle" qualifier="*" ref="UT_hash_handle#UT_hash_handle" />
  </field>
  <field id="UT_hash_table::hho" name="hho">
    <brief>tail hh in app order, for fast append</brief>
    <type name="ptrdiff_t" />
  </field>
  <field id="UT_hash_table::ideal_chain_maxlen" name="ideal_chain_maxlen">
    <brief> in an ideal situation (all buckets used equally), no bucket would have</brief>
    <doc>more than ceil(#items/#buckets) items. that's the ideal chain length.</doc>
    <type builtin="yes" name="unsigned int" />
  </field>
  <field id="UT_hash_table::nonideal_items" name="nonideal_items">
    <brief> nonideal_items is the number of items in the hash whose chain position</brief>
    <doc>exceeds the ideal chain maxlen. these items pay the penalty for an uneven
hash distribution; reaching them in a chain traversal takes &gt;ideal steps</doc>
    <type builtin="yes" name="unsigned int" />
  </field>
  <field id="UT_hash_table::ineff_expands" name="ineff_expands">
    <brief> ineffective expands occur when a bucket doubling was performed, but</brief>
    <doc>afterward, more than half the items in the hash had nonideal chain
positions. If this happens on two consecutive expansions we inhibit any
further expansion, as it's not helping; this happens when the hash
function isn't a good fit for the key domain. When expansion is inhibited
the hash will still work, albeit no longer in constant time.</doc>
    <type builtin="yes" name="unsigned int" />
  </field>
  <field id="UT_hash_table::noexpand" name="noexpand">
    <brief> ineffective expands occur when a bucket doubling was performed, but</brief>
    <doc>afterward, more than half the items in the hash had nonideal chain
positions. If this happens on two consecutive expansions we inhibit any
further expansion, as it's not helping; this happens when the hash
function isn't a good fit for the key domain. When expansion is inhibited
the hash will still work, albeit no longer in constant time.</doc>
    <type builtin="yes" name="unsigned int" />
  </field>
  <field id="UT_hash_table::signature" name="signature">
    <type name="uint32_t" />
  </field>
</struct>
